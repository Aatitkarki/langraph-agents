# software_dev_agents/release_manager.py
from typing import TypedDict, Optional, Literal, List
from langgraph.graph import StateGraph, END, START
import datetime

# --- State Definition ---

class Task(TypedDict):
    """Represents a task to be completed. (Copied for clarity, ideally import)"""
    id: str
    description: str
    status: Literal["pending", "in_progress", "completed", "blocked", "failed", "needs_review", "review_approved", "review_rejected"]
    assigned_to: Optional[str]
    result: Optional[str]
    parent_task_id: Optional[str]

class ReleaseManagerState(TypedDict):
    """State specific to the Release Manager."""
    task_in_progress: Optional[Task] # The specific release coordination task
    tasks_to_check: Optional[List[Task]] # List of tasks (dev, QA, security) to verify completion/approval
    release_notes_draft: Optional[str] # Output: Draft of release notes
    release_decision: Optional[Literal["approved", "rejected"]] # Output: Decision on release readiness

# --- Node Functions ---

def check_release_readiness(state: ReleaseManagerState) -> dict:
    """
    Checks if all prerequisite tasks (development, QA, security) are completed and approved.
    """
    print("---RELEASE MANAGER: Checking Release Readiness---")
    task = state.get('task_in_progress')
    tasks_to_check = state.get('tasks_to_check', [])

    if not task:
        print("Error: No task assigned to Release Manager.")
        return {"release_decision": "rejected"}

    print(f"Checking readiness for task: {task['description']}")
    print(f"Verifying status of {len(tasks_to_check)} prerequisite tasks.")

    ready_for_release = True
    blocking_issues = []

    for prereq_task in tasks_to_check:
        # Define passing statuses (adjust as needed)
        passing_statuses = ["completed", "review_approved"]
        if prereq_task.get('status') not in passing_statuses:
            ready_for_release = False
            blocking_issues.append(f"Task '{prereq_task.get('id', 'Unknown')}' not completed/approved (Status: {prereq_task.get('status', 'N/A')}).")

    if ready_for_release:
        print("All prerequisite tasks completed/approved. Ready for release notes.")
        return {"release_decision": "approved"}
    else:
        print("Release blocked due to incomplete/unapproved tasks:")
        for issue in blocking_issues:
            print(f"- {issue}")
        # Update task result with blocking issues
        task['result'] = "Release Blocked:\n" + "\n".join(blocking_issues)
        task['status'] = 'blocked'
        return {"release_decision": "rejected", "task_in_progress": task}


def draft_release_notes(state: ReleaseManagerState) -> dict:
    """
    Drafts release notes based on completed tasks if release is approved.
    """
    print("---RELEASE MANAGER: Drafting Release Notes---")
    if state.get("release_decision") != "approved":
        print("Skipping release notes draft as release is not approved.")
        return {}

    task = state.get('task_in_progress')
    tasks_completed = state.get('tasks_to_check', []) # Assuming these are the relevant tasks

    print(f"Drafting release notes for: {task['description']}")

    # Placeholder Logic: Generate release notes (LLM summarizing completed tasks)
    release_version = f"v1.{datetime.date.today().strftime('%Y%m%d')}"
    notes = f"**Release Notes - {release_version}**\n\n"
    notes += f"**Release Date:** {datetime.date.today()}\n\n"
    notes += "**Features/Fixes Included:**\n"
    for completed_task in tasks_completed:
        if completed_task.get('status') in ["completed", "review_approved"]:
             # Extract meaningful summary from task description or result
             summary = completed_task.get('description', 'N/A').split('for')[-1].strip()
             notes += f"- Implemented/Tested: {summary} (Task ID: {completed_task.get('id')})\n"

    notes += "\n**(Note: Placeholder release notes generated by Release Manager agent.)**"
    print("Generated Release Notes Draft (Placeholder)")
    return {"release_notes_draft": notes}

def finalize_release_process(state: ReleaseManagerState) -> dict:
    """
    Marks the release task as completed (or blocked) and bundles the results.
    """
    print("---RELEASE MANAGER: Finalizing Release Process---")
    task = state.get('task_in_progress')
    release_decision = state.get('release_decision')
    release_notes = state.get('release_notes_draft')

    if not task:
        print("Error: No task to finalize.")
        return {}

    updated_task = task.copy()
    if release_decision == "approved":
        updated_task['status'] = 'completed'
        updated_task['result'] = release_notes or "Release approved, notes generated."
        print(f"Release task {task['id']} approved and completed.")
    elif release_decision == "rejected":
        # Status might have already been set to 'blocked' in check_release_readiness
        if updated_task.get('status') != 'blocked':
             updated_task['status'] = 'blocked'
        print(f"Release task {task['id']} rejected/blocked.")
        # Result might contain blocking issues already
    else:
        updated_task['status'] = 'failed' # Should not happen if check ran
        updated_task['result'] = "Error in release process."
        print(f"Release task {task['id']} failed.")


    # Return the updated task object
    return {"task_in_progress": updated_task}

# --- Routing ---
def decide_after_readiness_check(state: ReleaseManagerState) -> Literal["draft_release_notes", "finalize_release_process"]:
    """Routes based on the release readiness decision."""
    if state.get("release_decision") == "approved":
        return "draft_release_notes"
    else: # Rejected or error
        return "finalize_release_process" # Go directly to finalize to report blockage/failure

# --- Graph Definition ---
release_manager_workflow = StateGraph(ReleaseManagerState)

release_manager_workflow.add_node("check_readiness", check_release_readiness)
release_manager_workflow.add_node("draft_release_notes", draft_release_notes)
release_manager_workflow.add_node("finalize_release", finalize_release_process)

release_manager_workflow.add_edge(START, "check_readiness")
release_manager_workflow.add_conditional_edges(
    "check_readiness",
    decide_after_readiness_check,
    {
        "draft_release_notes": "draft_release_notes",
        "finalize_release_process": "finalize_release" # Go straight to end if rejected
    }
)
release_manager_workflow.add_edge("draft_release_notes", "finalize_release")
release_manager_workflow.add_edge("finalize_release", END)

# --- Compile the Graph ---
release_manager_agent = release_manager_workflow.compile()

# Note: Receives 'task_in_progress', 'tasks_to_check'. Returns updated 'task_in_progress'.