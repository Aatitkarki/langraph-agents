# software_dev_agents/tech_writer.py
from typing import TypedDict, Optional, Literal, List
from langgraph.graph import StateGraph, END, START

# --- State Definition ---

class Task(TypedDict):
    """Represents a task to be completed. (Copied for clarity, ideally import)"""
    id: str
    description: str
    status: Literal["pending", "in_progress", "completed", "blocked", "failed"]
    assigned_to: Optional[str]
    result: Optional[str]
    parent_task_id: Optional[str]

class TechWriterState(TypedDict):
    """State specific to the Technical Writer."""
    task_in_progress: Optional[Task] # The specific documentation task assigned
    feature_details: Optional[str] # Details of the feature/API/code to document
    target_audience: Optional[str] # E.g., 'end-user', 'developer'
    documentation_draft: Optional[str] # Output: Draft of the documentation

# --- Node Functions ---

def write_documentation(state: TechWriterState) -> dict:
    """
    Writes documentation based on the feature details and target audience.
    """
    print("---TECHNICAL WRITER: Writing Documentation---")
    task = state.get('task_in_progress')
    feature = state.get('feature_details', 'N/A')
    audience = state.get('target_audience', 'developer') # Default to developer docs

    if not task:
        print("Error: No task assigned to Technical Writer.")
        return {"documentation_draft": "Error: No task found."}

    print(f"Writing documentation for task: {task['description']}")
    print(f"Target Audience: {audience}")
    print(f"Based on Feature Details: {feature[:100]}...") # Print snippet

    # Placeholder Logic: Generate documentation (LLM call)
    doc_type = "User Manual" if audience == 'end-user' else "API Documentation"
    documentation_draft = f"""
**{doc_type}: {task['description'].replace('Write documentation for ', '')}**

**Target Audience:** {audience}

**Based on:**
{feature}

**Section 1: Introduction**
- Overview of the feature/API.

**Section 2: Usage**
- Step-by-step guide (for users) or endpoint details (for developers).
- Code examples or usage scenarios.

**Section 3: Troubleshooting / API Reference**
- Common issues or detailed parameter descriptions.

**(Note: This is a placeholder generated by the Tech Writer agent.)**
"""
    print("Generated Documentation Draft (Placeholder)")
    return {"documentation_draft": documentation_draft}

def finalize_documentation(state: TechWriterState) -> dict:
    """
    Marks the documentation task as completed and bundles the draft.
    """
    print("---TECHNICAL WRITER: Finalizing Documentation---")
    task = state.get('task_in_progress')
    documentation_draft = state.get('documentation_draft')

    if not task:
        print("Error: No task to finalize.")
        return {}

    # Update task status
    updated_task = task.copy()
    if documentation_draft and "Error:" not in documentation_draft:
        updated_task['status'] = 'completed'
        updated_task['result'] = documentation_draft
        print(f"Documentation task {task['id']} completed.")
    else:
        updated_task['status'] = 'failed' # Or blocked, depending on error handling
        updated_task['result'] = documentation_draft or "Failed to generate documentation."
        print(f"Documentation task {task['id']} failed.")

    # Return the updated task object
    return {"task_in_progress": updated_task}

# --- Graph Definition ---
tech_writer_workflow = StateGraph(TechWriterState)

tech_writer_workflow.add_node("write_documentation", write_documentation)
tech_writer_workflow.add_node("finalize_documentation", finalize_documentation)

tech_writer_workflow.add_edge(START, "write_documentation")
tech_writer_workflow.add_edge("write_documentation", "finalize_documentation")
tech_writer_workflow.add_edge("finalize_documentation", END)

# --- Compile the Graph ---
tech_writer_agent = tech_writer_workflow.compile()

# Note: This agent receives 'task_in_progress', 'feature_details', 'target_audience',
# returns the updated 'task_in_progress' with the documentation draft.